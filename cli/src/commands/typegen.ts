/**
 * Typegen command - generates TypeScript type definitions from manifest.
 * Per REP-RFC-0001 §5.4 and TASKS.md P4.
 */

import { Command } from 'commander';
import chalk from 'chalk';
import * as fs from 'fs';
import * as path from 'path';
import { loadManifest } from '../utils/manifest.js';

export function createTypegenCommand(): Command {
  const cmd = new Command('typegen');
  
  cmd
    .description('Generate TypeScript type definitions from manifest')
    .option('-m, --manifest <path>', 'Path to .rep.yaml manifest file', '.rep.yaml')
    .option('-o, --output <path>', 'Output path for generated .d.ts file', 'src/rep.d.ts')
    .action(async (options) => {
      const manifestPath = options.manifest;
      const outputPath = options.output;
      
      try {
        console.log(chalk.blue(`Loading manifest: ${manifestPath}`));
        const manifest = loadManifest(manifestPath);
        
        // Collect variable names by tier
        const publicVars: string[] = [];
        const sensitiveVars: string[] = [];
        
        for (const [name, config] of Object.entries(manifest.variables)) {
          if (config.tier === 'public') {
            publicVars.push(name);
          } else if (config.tier === 'sensitive') {
            sensitiveVars.push(name);
          }
          // SERVER vars are not accessible from the client
        }
        
        // Generate TypeScript declaration
        const dts = generateTypeDefinition(publicVars, sensitiveVars);
        
        // Ensure output directory exists
        const outputDir = path.dirname(outputPath);
        if (!fs.existsSync(outputDir)) {
          fs.mkdirSync(outputDir, { recursive: true });
        }
        
        // Write the file
        fs.writeFileSync(outputPath, dts, 'utf-8');
        
        console.log(chalk.green(`✓ Generated type definitions: ${outputPath}`));
        console.log(chalk.gray(`  PUBLIC variables: ${publicVars.length}`));
        console.log(chalk.gray(`  SENSITIVE variables: ${sensitiveVars.length}`));
        
        process.exit(0);
      } catch (err) {
        console.error(chalk.red('✗ Type generation failed'));
        console.error(chalk.red(err instanceof Error ? err.message : String(err)));
        process.exit(1);
      }
    });
  
  return cmd;
}

function generateTypeDefinition(publicVars: string[], sensitiveVars: string[]): string {
  const lines: string[] = [];
  
  lines.push('/**');
  lines.push(' * Auto-generated TypeScript definitions for REP variables.');
  lines.push(' * Generated by @rep-protocol/cli typegen command.');
  lines.push(' * DO NOT EDIT MANUALLY - regenerate with `rep typegen`');
  lines.push(' */');
  lines.push('');
  lines.push('declare module "@rep-protocol/sdk" {');
  lines.push('  export interface REP {');
  lines.push('    /**');
  lines.push('     * Get a PUBLIC tier variable value synchronously.');
  lines.push('     */');
  
  if (publicVars.length > 0) {
    lines.push('    get(key: ' + publicVars.map(v => `"${v}"`).join(' | ') + '): string | undefined;');
  } else {
    lines.push('    get(key: string): string | undefined;');
  }
  
  lines.push('');
  lines.push('    /**');
  lines.push('     * Get a SENSITIVE tier variable value asynchronously.');
  lines.push('     */');
  
  if (sensitiveVars.length > 0) {
    lines.push('    getSecure(key: ' + sensitiveVars.map(v => `"${v}"`).join(' | ') + '): Promise<string>;');
  } else {
    lines.push('    getSecure(key: string): Promise<string>;');
  }
  
  lines.push('');
  lines.push('    /**');
  lines.push('     * Subscribe to changes for a specific variable.');
  lines.push('     */');
  lines.push('    onChange(key: string, callback: (newValue: string | undefined) => void): () => void;');
  lines.push('');
  lines.push('    /**');
  lines.push('     * Subscribe to any variable change.');
  lines.push('     */');
  lines.push('    onAnyChange(callback: () => void): () => void;');
  lines.push('');
  lines.push('    /**');
  lines.push('     * Verify payload integrity.');
  lines.push('     */');
  lines.push('    verify(): Promise<boolean>;');
  lines.push('');
  lines.push('    /**');
  lines.push('     * Get payload metadata.');
  lines.push('     */');
  lines.push('    meta(): {');
  lines.push('      version: string;');
  lines.push('      injected_at: string;');
  lines.push('      integrity: string;');
  lines.push('      key_endpoint: string;');
  lines.push('      hot_reload?: string;');
  lines.push('      ttl: number;');
  lines.push('    } | null;');
  lines.push('  }');
  lines.push('');
  lines.push('  export const rep: REP;');
  lines.push('  export function get(key: string): string | undefined;');
  lines.push('  export function getSecure(key: string): Promise<string>;');
  lines.push('  export function onChange(key: string, callback: (newValue: string | undefined) => void): () => void;');
  lines.push('  export function onAnyChange(callback: () => void): () => void;');
  lines.push('  export function verify(): Promise<boolean>;');
  lines.push('  export function meta(): ReturnType<REP["meta"]>;');
  lines.push('}');
  lines.push('');
  
  return lines.join('\n');
}
